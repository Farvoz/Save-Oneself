<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Marooned Game Tests</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
    }
    .test-suite {
      margin-bottom: 30px;
    }
    .test-case {
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 5px;
    }
    .pass {
      background-color: #e6ffec;
      border-left: 5px solid #2da44e;
    }
    .fail {
      background-color: #ffebe9;
      border-left: 5px solid #cf222e;
    }
    h1, h2 {
      color: #333;
    }
    .results-summary {
      margin-top: 20px;
      padding: 15px;
      background-color: #f6f8fa;
      border-radius: 5px;
    }
    .test-controls {
      margin-bottom: 20px;
    }
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background-color: #2da44e;
      color: white;
      cursor: pointer;
      margin-right: 10px;
    }
    button:hover {
      background-color: #2c974b;
    }
    .mock-board {
      display: grid;
      grid-template-columns: repeat(4, 50px);
      grid-template-rows: repeat(4, 50px);
      gap: 5px;
      margin: 20px 0;
    }
    .mock-cell {
      width: 50px;
      height: 50px;
      background-color: #f1f1f1;
      border: 1px solid #ddd;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .mock-cell.filled {
      background-color: #c9e6ff;
    }
    .mock-cell.player {
      border: 2px solid #ff9900;
    }
    .mock-cell.ship {
      border: 2px solid #ff0000;
    }
  </style>
</head>
<body>
  <h1>Marooned Game Tests</h1>
  
  <div class="test-controls">
    <button id="runAll">Run All Tests</button>
    <button id="clearResults">Clear Results</button>
  </div>
  
  <div class="mock-board" id="mockBoard"></div>
  
  <div id="testResults">
    <div id="testContainer" class="test-suite"></div>
    <div id="resultsSummary" class="results-summary"></div>
  </div>

  <script>
    // Mock game state for testing
    let mockGameState = {
      health: 16,
      deck: [],
      board: Array(16).fill(null),
      playerPosition: null,
      shipPosition: null,
      shipDirection: null,
      shipInPort: true,
      score: 0,
      cardsPlayed: 0,
      gameOver: false,
      rescued: false
    };

    // Mock card types
    const mockCards = [
      { name: 'Water', icons: ['health'], healthBonus: 2, vp: 1, requirement: null },
      { name: 'Food', icons: ['health'], healthBonus: 1, vp: 1, requirement: null },
      { name: 'Shelter', icons: ['health'], healthBonus: 2, vp: 2, requirement: null },
      { name: 'Fire', icons: ['flip'], vp: 2, requirement: 'wood' },
      { name: 'Wood', icons: [], vp: 1, requirement: null },
      { name: 'Rocks', icons: [], vp: 1, requirement: null },
      { name: 'SOS', icons: ['flip'], vp: 5, requirement: 'rocks' },
      { name: 'Ship', icons: ['ship'], vp: 0, requirement: null }
    ];

    // Mock DOM elements
    const mockDOM = {
      gameLog: {
        messages: [],
        appendChild: function(p) {
          this.messages.push(p.textContent);
        },
        clearMessages: function() {
          this.messages = [];
        }
      }
    };

    // Modified game functions for testing
    function resetMockGameState() {
      mockGameState = {
        health: 16,
        deck: [...mockCards],
        board: Array(16).fill(null),
        playerPosition: null,
        shipPosition: null,
        shipDirection: null,
        shipInPort: true,
        score: 0,
        cardsPlayed: 0,
        gameOver: false,
        rescued: false
      };
      mockDOM.gameLog.clearMessages();
    }

    // Mock logMessage function
    function logMessage(message) {
      const logEntry = { textContent: message };
      mockDOM.gameLog.appendChild(logEntry);
    }

    // Test shuffle deck
    function shuffleDeck() {
      const originalDeck = [...mockGameState.deck];
      for (let i = mockGameState.deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [mockGameState.deck[i], mockGameState.deck[j]] = [mockGameState.deck[j], mockGameState.deck[i]];
      }
      return originalDeck.some((card, index) => card !== mockGameState.deck[index]);
    }

    // Place a card on the board
    function placeCard(card, index) {
      mockGameState.board[index] = { ...card, flipped: false };
    }

    // Move player to a position
    function movePlayer(index) {
      mockGameState.playerPosition = index;
      
      // Apply health effect of the card if it has a health icon
      const card = mockGameState.board[index];
      if (card && card.icons.includes('health')) {
        updateHealth(card.healthBonus);
        logMessage(`You ${card.healthBonus > 0 ? 'gained' : 'lost'} ${Math.abs(card.healthBonus)} health from ${card.name}.`);
      }
    }

    // Update player health
    function updateHealth(change) {
      mockGameState.health += change;
      if (mockGameState.health <= 0) {
        mockGameState.health = 0;
        endGame(false, "You ran out of health and perished on the island.");
      }
    }

    // End the game
    function endGame(success, message) {
      mockGameState.gameOver = true;
      mockGameState.rescued = success;
      logMessage(message);
    }
    
    // Check if a move is valid
    function isValidMove(targetIndex) {
      const BOARD_SIZE = 4;
      
      // Moving to an existing card is valid if adjacent
      if (mockGameState.board[targetIndex] !== null) {
        const currentRow = Math.floor(mockGameState.playerPosition / BOARD_SIZE);
        const currentCol = mockGameState.playerPosition % BOARD_SIZE;
        const targetRow = Math.floor(targetIndex / BOARD_SIZE);
        const targetCol = targetIndex % BOARD_SIZE;
        
        return Math.abs(currentRow - targetRow) <= 1 && 
               Math.abs(currentCol - targetCol) <= 1 &&
               !(currentRow === targetRow && currentCol === targetCol);
      }
      
      // For placing a new card, it must be adjacent to current position
      const currentRow = Math.floor(mockGameState.playerPosition / BOARD_SIZE);
      const currentCol = mockGameState.playerPosition % BOARD_SIZE;
      const targetRow = Math.floor(targetIndex / BOARD_SIZE);
      const targetCol = targetIndex % BOARD_SIZE;
      
      return Math.abs(currentRow - targetRow) <= 1 && 
             Math.abs(currentCol - targetCol) <= 1 &&
             !(currentRow === targetRow && currentCol === targetCol);
    }

    // Try to flip a card
    function tryFlipCard(index) {
      const card = mockGameState.board[index];
      if (!card || card.flipped) return false;
      
      // Check if requirement is met
      if (card.requirement) {
        const requirementMet = mockGameState.board.some(c => 
          c && c.name.toLowerCase() === card.requirement.toLowerCase());
        
        if (!requirementMet) {
          logMessage(`You need a ${card.requirement} card to flip this ${card.name} card.`);
          return false;
        }
      }
      
      // Flip the card
      card.flipped = true;
      logMessage(`You flipped the ${card.name} card.`);
      
      // Special actions for flipped cards
      if (card.name === 'SOS' || card.name === 'Beacon' || card.name === 'Message') {
        if (!mockGameState.shipInPort && mockGameState.shipPosition !== null) {
          logMessage(`The ship spotted your ${card.name}!`);
          rescuePlayer();
        }
      }
      
      return true;
    }

    // Rescue player
    function rescuePlayer() {
      mockGameState.rescued = true;
      calculateScore();
      endGame(true, "You've been rescued from the island!");
    }

    // Calculate final score
    function calculateScore() {
      let score = 0;
      
      // Add VP from cards in play
      mockGameState.board.forEach(card => {
        if (card) score += card.vp;
      });
      
      // Add health bonus
      score += mockGameState.health;
      
      // Add bonus for cards played: Cards played รท 4, rounding down fractions
      score += Math.floor(mockGameState.cardsPlayed / 4);
      
      mockGameState.score = score;
    }

    // Move the ship
    function moveShip() {
      if (mockGameState.shipInPort || mockGameState.shipPosition === null) return false;
      
      const BOARD_SIZE = 4;
      const directions = [
        [-1, 0],  // North
        [0, 1],   // East
        [1, 0],   // South
        [0, -1]   // West
      ];
      
      const [rowDelta, colDelta] = directions[mockGameState.shipDirection];
      const currentRow = Math.floor(mockGameState.shipPosition / BOARD_SIZE);
      const currentCol = mockGameState.shipPosition % BOARD_SIZE;
      
      const newRow = currentRow + rowDelta;
      const newCol = currentCol + colDelta;
      
      // Check if ship is at edge or has completed its path
      if (newRow < 0 || newRow >= BOARD_SIZE || newCol < 0 || newCol >= BOARD_SIZE) {
        // Ship returns to port
        mockGameState.shipInPort = true;
        mockGameState.shipPosition = null;
        logMessage("The ship has returned to port.");
        return true;
      } else {
        // Move ship
        mockGameState.shipPosition = newRow * BOARD_SIZE + newCol;
        logMessage("The ship moved along the coast.");
        
        // Check if player can be rescued by the ship
        checkShipRescue();
        return true;
      }
    }

    // Check if ship can rescue player
    function checkShipRescue() {
      const BOARD_SIZE = 4;
      
      if (mockGameState.shipPosition === mockGameState.playerPosition) {
        logMessage("The ship spotted you on the shore!");
        rescuePlayer();
        return true;
      }
      
      // Check if ship can see SOS, beacon or message
      for (let i = 0; i < mockGameState.board.length; i++) {
        const card = mockGameState.board[i];
        if (!card || !card.flipped) continue;
        
        if ((card.name === 'SOS' || card.name === 'Beacon' || card.name === 'Message')) {
          // Calculate if card is visible from ship position
          const cardRow = Math.floor(i / BOARD_SIZE);
          const cardCol = i % BOARD_SIZE;
          const shipRow = Math.floor(mockGameState.shipPosition / BOARD_SIZE);
          const shipCol = mockGameState.shipPosition % BOARD_SIZE;
          
          // The ship can see the signal if it's adjacent (including diagonally)
          if (Math.abs(cardRow - shipRow) <= 1 && Math.abs(cardCol - shipCol) <= 1) {
            logMessage(`The ship spotted your ${card.name}!`);
            rescuePlayer();
            return true;
          }
        }
      }
      
      return false;
    }

    // Launch a ship
    function launchShip(cardIndex) {
      const BOARD_SIZE = 4;
      
      if (!mockGameState.shipInPort) {
        logMessage("A ship is already sailing. This ship has sailed elsewhere.");
        return false;
      }
      
      mockGameState.shipInPort = false;
      
      // Determine ship starting position based on where the ship card was played
      const row = Math.floor(cardIndex / BOARD_SIZE);
      const col = cardIndex % BOARD_SIZE;
      
      let startPos, direction;
      
      // NW corner
      if (row < BOARD_SIZE / 2 && col < BOARD_SIZE / 2) {
        startPos = 0; // NW corner
        direction = 1; // East
      } 
      // NE corner
      else if (row < BOARD_SIZE / 2 && col >= BOARD_SIZE / 2) {
        startPos = BOARD_SIZE - 1; // NE corner
        direction = 2; // South
      }
      // SW corner
      else if (row >= BOARD_SIZE / 2 && col < BOARD_SIZE / 2) {
        startPos = BOARD_SIZE * (BOARD_SIZE - 1); // SW corner
        direction = 0; // North
      }
      // SE corner
      else {
        startPos = BOARD_SIZE * BOARD_SIZE - 1; // SE corner
        direction = 3; // West
      }
      
      mockGameState.shipPosition = startPos;
      mockGameState.shipDirection = direction;
      
      logMessage("A ship has set sail and can be seen off the coast!");
      
      // Check if ship can rescue immediately
      checkShipRescue();
      return true;
    }

    function playerTurn(targetIndex) {
      if (mockGameState.gameOver) return false;
      
      // Check if it's a valid move
      if (!isValidMove(targetIndex)) {
        logMessage("You can only move to adjacent spaces.");
        return false;
      }
      
      // Draw a card if the space is empty
      if (mockGameState.board[targetIndex] === null) {
        if (mockGameState.deck.length === 0) {
          logMessage("No more cards in the deck!");
          return false;
        }
        
        const card = mockGameState.deck.pop();
        placeCard(card, targetIndex);
        mockGameState.cardsPlayed++;
        
        // Check if it's a ship card
        if (card.icons.includes('ship') && mockGameState.shipInPort) {
          launchShip(targetIndex);
        }
      }
      
      // Move player
      movePlayer(targetIndex);
      
      // Reduce health by 1 for the turn
      updateHealth(-1);
      logMessage("You used 1 health point for this turn.");
      
      // Move ship if it's in play
      moveShip();
      
      return true;
    }

    // Test utilities
    function assertEqual(actual, expected, message) {
      return {
        pass: actual === expected,
        message: message || `Expected ${expected}, got ${actual}`
      };
    }

    function assertTrue(condition, message) {
      return {
        pass: condition === true,
        message: message || `Expected true, got ${condition}`
      };
    }

    function assertFalse(condition, message) {
      return {
        pass: condition === false,
        message: message || `Expected false, got ${condition}`
      };
    }

    function assertNotNull(value, message) {
      return {
        pass: value !== null,
        message: message || `Expected not null, got ${value}`
      };
    }

    function assertArrayContains(array, value, message) {
      return {
        pass: array.includes(value),
        message: message || `Expected array to contain ${value}`
      };
    }

    function runTest(testName, testFunction) {
      resetMockGameState();
      const resultContainer = document.getElementById('testContainer');
      
      try {
        const result = testFunction();
        const testCase = document.createElement('div');
        testCase.classList.add('test-case');
        testCase.classList.add(result.pass ? 'pass' : 'fail');
        testCase.innerHTML = `
          <strong>${testName}:</strong> ${result.pass ? 'PASS' : 'FAIL'}<br>
          ${!result.pass ? result.message : ''}
        `;
        resultContainer.appendChild(testCase);
        return result.pass;
      } catch (e) {
        const testCase = document.createElement('div');
        testCase.classList.add('test-case', 'fail');
        testCase.innerHTML = `
          <strong>${testName}:</strong> ERROR<br>
          ${e.message}<br>
          ${e.stack}
        `;
        resultContainer.appendChild(testCase);
        return false;
      }
    }

    // Test cases
    const tests = [
      {
        name: "Test shuffleDeck",
        test: function() {
          mockGameState.deck = Array(10).fill().map((_, i) => ({ name: `Card ${i}` }));
          const wasShuffled = shuffleDeck();
          return assertTrue(wasShuffled, "Deck should be shuffled");
        }
      },
      {
        name: "Test placeCard",
        test: function() {
          const card = { name: 'Test Card', icons: [], vp: 1 };
          placeCard(card, 5);
          return assertNotNull(mockGameState.board[5], "Card should be placed on board");
        }
      },
      {
        name: "Test movePlayer",
        test: function() {
          movePlayer(7);
          return assertEqual(mockGameState.playerPosition, 7, "Player should move to position 7");
        }
      },
      {
        name: "Test movePlayer with health card",
        test: function() {
          const card = { name: 'Water', icons: ['health'], healthBonus: 2, vp: 1 };
          placeCard(card, 10);
          const initialHealth = mockGameState.health;
          movePlayer(10);
          return assertEqual(mockGameState.health, initialHealth + 2, "Player should gain 2 health");
        }
      },
      {
        name: "Test updateHealth",
        test: function() {
          mockGameState.health = 10;
          updateHealth(-3);
          return assertEqual(mockGameState.health, 7, "Health should decrease by 3");
        }
      },
      {
        name: "Test updateHealth with game over",
        test: function() {
          mockGameState.health = 2;
          updateHealth(-5);
          return assertTrue(mockGameState.gameOver, "Game should be over when health reaches 0");
        }
      },
      {
        name: "Test isValidMove adjacency",
        test: function() {
          mockGameState.playerPosition = 5; // Position (1,1)
          const valid = isValidMove(0); // Position (0,0) - should be adjacent diagonally
          return assertTrue(valid, "Diagonal moves should be valid");
        }
      },
      {
        name: "Test isValidMove non-adjacency",
        test: function() {
          mockGameState.playerPosition = 5; // Position (1,1)
          const valid = isValidMove(15); // Position (3,3) - should not be adjacent
          return assertFalse(valid, "Non-adjacent moves should be invalid");
        }
      },
      {
        name: "Test tryFlipCard with no requirement",
        test: function() {
          const card = { name: 'Wood', icons: [], vp: 1, requirement: null };
          placeCard(card, 0);
          const result = tryFlipCard(0);
          const isFlipped = mockGameState.board[0].flipped;
          return assertTrue(result && isFlipped, "Card should be flipped");
        }
      },
      {
        name: "Test tryFlipCard with unmet requirement",
        test: function() {
          const card = { name: 'Fire', icons: ['flip'], vp: 2, requirement: 'wood' };
          placeCard(card, 0);
          const result = tryFlipCard(0);
          return assertFalse(result, "Card should not flip with unmet requirement");
        }
      },
      {
        name: "Test tryFlipCard with met requirement",
        test: function() {
          const requirementCard = { name: 'Wood', icons: [], vp: 1, requirement: null };
          const card = { name: 'Fire', icons: ['flip'], vp: 2, requirement: 'wood' };
          placeCard(requirementCard, 1);
          placeCard(card, 0);
          const result = tryFlipCard(0);
          return assertTrue(result, "Card should flip with met requirement");
        }
      },
      {
        name: "Test rescuePlayer",
        test: function() {
          rescuePlayer();
          return assertTrue(mockGameState.rescued && mockGameState.gameOver, "Player should be rescued and game over");
        }
      },
      {
        name: "Test calculateScore",
        test: function() {
          // Place some cards with VP
          mockGameState.board[0] = { name: 'Water', vp: 1 };
          mockGameState.board[1] = { name: 'Food', vp: 1 };
          mockGameState.board[2] = { name: 'Shelter', vp: 2 };
          mockGameState.health = 5;
          mockGameState.cardsPlayed = 10;
          
          calculateScore();
          // Expected: 1 + 1 + 2 + 5 + Math.floor(10/4) = 11
          return assertEqual(mockGameState.score, 11, "Score should be calculated correctly");
        }
      },
      {
        name: "Test moveShip at edge",
        test: function() {
          mockGameState.shipInPort = false;
          mockGameState.shipPosition = 3; // Top right
          mockGameState.shipDirection = 1; // East
          moveShip();
          return assertTrue(mockGameState.shipInPort, "Ship should return to port when at edge");
        }
      },
      {
        name: "Test moveShip normal movement",
        test: function() {
          mockGameState.shipInPort = false;
          mockGameState.shipPosition = 0; // Top left
          mockGameState.shipDirection = 1; // East
          moveShip();
          return assertEqual(mockGameState.shipPosition, 1, "Ship should move east");
        }
      },
      {
        name: "Test checkShipRescue with player at ship position",
        test: function() {
          mockGameState.shipInPort = false;
          mockGameState.shipPosition = 7;
          mockGameState.playerPosition = 7;
          const result = checkShipRescue();
          return assertTrue(result && mockGameState.rescued, 
            "Player should be rescued when at same position as ship");
        }
      },
      {
        name: "Test checkShipRescue with SOS signal",
        test: function() {
          mockGameState.shipInPort = false;
          mockGameState.shipPosition = 0;
          mockGameState.board[1] = { name: 'SOS', flipped: true };
          const result = checkShipRescue();
          return assertTrue(result && mockGameState.rescued, 
            "Player should be rescued when ship is adjacent to flipped SOS");
        }
      },
      {
        name: "Test launchShip in NW quadrant",
        test: function() {
          mockGameState.shipInPort = true;
          launchShip(0); // NW quadrant
          return assertEqual(mockGameState.shipPosition, 0, "Ship should start at NW corner");
        }
      },
      {
        name: "Test launchShip in SE quadrant",
        test: function() {
          mockGameState.shipInPort = true;
          launchShip(15); // SE quadrant
          return assertEqual(mockGameState.shipPosition, 15, "Ship should start at SE corner");
        }
      },
      {
        name: "Test launchShip when ship already launched",
        test: function() {
          mockGameState.shipInPort = false;
          mockGameState.shipPosition = 0;
          const result = launchShip(15);
          return assertFalse(result, "Should not launch another ship if one is already sailing");
        }
      },
      {
        name: "Test playerTurn with valid move",
        test: function() {
          mockGameState.playerPosition = 5;
          mockGameState.deck = [{ name: 'Water', icons: ['health'], healthBonus: 2, vp: 1 }];
          const result = playerTurn(9); // Position (2,1)
          return assertTrue(result && mockGameState.playerPosition === 9, 
            "Player should move to valid position");
        }
      },
      {
        name: "Test playerTurn with invalid move",
        test: function() {
          mockGameState.playerPosition = 5;
          const result = playerTurn(15); // Position (3,3) - not adjacent
          return assertFalse(result, "Player should not move to invalid position");
        }
      },
      {
        name: "Test playerTurn health reduction",
        test: function() {
          mockGameState.playerPosition = 5;
          mockGameState.health = 10;
          playerTurn(6); // Adjacent position
          return assertEqual(mockGameState.health, 9, "Health should decrease by 1 per turn");
        }
      },
      {
        name: "Test playerTurn with Ship card",
        test: function() {
          mockGameState.playerPosition = 5;
          mockGameState.deck = [{ name: 'Ship', icons: ['ship'], vp: 0 }];
          playerTurn(9);
          return assertFalse(mockGameState.shipInPort, "Ship should launch when Ship card is played");
        }
      }
    ];

    // Run all tests
    function runAllTests() {
      document.getElementById('testContainer').innerHTML = '';
      document.getElementById('resultsSummary').innerHTML = '';
      
      let passed = 0;
      let failed = 0;
      
      tests.forEach(test => {
        if (runTest(test.name, test.test)) {
          passed++;
        } else {
          failed++;
        }
      });
      
      const summary = document.getElementById('resultsSummary');
      summary.innerHTML = `
        <h2>Test Results</h2>
        <p>Total tests: ${tests.length}</p>
        <p>Passed: ${passed}</p>
        <p>Failed: ${failed}</p>
      `;
    }

    // Create mock board visualization
    function createMockBoard() {
      const mockBoard = document.getElementById('mockBoard');
      mockBoard.innerHTML = '';
      
      for (let i = 0; i < 16; i++) {
        const cell = document.createElement('div');
        cell.classList.add('mock-cell');
        cell.textContent = i;
        mockBoard.appendChild(cell);
      }
    }

    // Event listeners
    document.getElementById('runAll').addEventListener('click', runAllTests);
    document.getElementById('clearResults').addEventListener('click', function() {
      document.getElementById('testContainer').innerHTML = '';
      document.getElementById('resultsSummary').innerHTML = '';
    });

    // Initialize
    createMockBoard();
    // Run tests automatically on load
    runAllTests();
  </script>
</body>
</html>