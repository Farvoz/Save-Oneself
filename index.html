<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Marooned!</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #b2e2f2;
      margin: 0;
      padding: 20px;
      user-select: none;
    }
    .game-container {
      display: flex;
      justify-content: space-between;
      max-width: 1200px;
      margin: 0 auto;
      gap: 20px;
    }
    .game-board {
      display: grid;
      grid-template-columns: repeat(4, 100px);
      grid-template-rows: repeat(4, 100px);
      gap: 10px;
      margin-bottom: 20px;
    }
    .card-placeholder {
      background-color: rgba(255, 255, 255, 0.2);
      border: 2px dashed #888;
      border-radius: 10px;
    }
    .card {
      width: 100px;
      height: 100px;
      background-color: #f8f8f8;
      border: 2px solid #333;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      position: relative;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
    }
    .card.active {
      box-shadow: 0 0 0 3px #ff9900;
    }
    .card .icons {
      display: flex;
      justify-content: space-between;
      padding: 5px;
    }
    .card .flip-requirement {
      font-size: 10px;
      background-color: rgba(0, 0, 0, 0.1);
      padding: 2px 5px;
      border-radius: 10px;
      position: absolute;
      bottom: 5px;
      left: 5px;
    }
    .card.flipped {
      background-color: #c9e6ff;
    }
    .footprints {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
      background-color: #333;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      z-index: 10;
    }
    .ship {
      position: absolute;
      width: 30px;
      height: 30px;
      background-color: #ff9900;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      z-index: 10;
    }
    .control-panel {
      width: 300px;
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
    }
    .deck {
      background-color: #ddd;
      width: 100px;
      height: 100px;
      border-radius: 10px;
      margin: 0 auto 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      border: 2px solid #333;
    }
    .health-tracker {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    .health-bar {
      width: 100%;
      height: 30px;
      background-color: #eee;
      border-radius: 15px;
      overflow: hidden;
      margin-top: 10px;
    }
    .health-fill {
      height: 100%;
      background-color: #4caf50;
      transition: width 0.3s;
    }
    .game-log {
      height: 150px;
      overflow-y: auto;
      border: 1px solid #ddd;
      padding: 10px;
      margin-top: 20px;
      background-color: #f9f9f9;
      font-size: 14px;
    }
    .game-log p {
      margin: 5px 0;
    }
    .icon {
      width: 20px;
      height: 20px;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      border-radius: 50%;
      font-size: 12px;
      font-weight: bold;
    }
    .icon-ship { background-color: #ff9900; color: white; }
    .icon-health { background-color: #4caf50; color: white; }
    .icon-vp { background-color: #9c27b0; color: white; }
    .icon-flip { background-color: #2196f3; color: white; }
    
    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .game-over-content {
      background-color: white;
      padding: 40px;
      border-radius: 10px;
      text-align: center;
      max-width: 500px;
    }
    .btn {
      background-color: #4caf50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 20px;
    }
    .btn:hover {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <h1 style="text-align: center; color: #333;">Marooned!</h1>
  <p style="text-align: center; margin-bottom: 30px;">The year is 1743. The sole survivor of a shipwreck, you find yourself washed up on a small island. Try to survive and get rescued!</p>
  
  <div class="game-container">
    <div>
      <div class="game-board" id="gameBoard"></div>
    </div>
    
    <div class="control-panel">
      <div class="deck" id="deck">
        <span id="deckCount">16</span> cards left
      </div>
      
      <div class="health-tracker">
        <div><strong>Health: <span id="healthValue">16</span></strong></div>
        <div class="health-bar">
          <div class="health-fill" id="healthFill" style="width: 100%;"></div>
        </div>
      </div>
      
      <div>
        <strong>Score: <span id="score">0</span></strong>
      </div>
      
      <div class="game-log" id="gameLog"></div>
      
      <button class="btn" id="newGameBtn">New Game</button>
    </div>
  </div>
  
  <div class="game-over" id="gameOver">
    <div class="game-over-content">
      <h2 id="gameOverTitle">Game Over</h2>
      <p id="gameOverMessage"></p>
      <p>Final Score: <strong id="finalScore">0</strong></p>
      <button class="btn" id="restartBtn">Play Again</button>
    </div>
  </div>

  <script>
    // Game constants
    const BOARD_SIZE = 4;
    const INITIAL_HEALTH = 16;
    const CARD_TYPES = [
      { name: 'Water', icons: ['health'], healthBonus: 2, vp: 1, requirement: null },
      { name: 'Food', icons: ['health'], healthBonus: 1, vp: 1, requirement: null },
      { name: 'Shelter', icons: ['health'], healthBonus: 2, vp: 2, requirement: null },
      { name: 'Fire', icons: ['flip'], vp: 2, requirement: 'wood' },
      { name: 'Wood', icons: [], vp: 1, requirement: null },
      { name: 'Rocks', icons: [], vp: 1, requirement: null },
      { name: 'SOS', icons: ['flip'], vp: 3, requirement: 'rocks' },
      { name: 'Beacon', icons: ['flip'], vp: 4, requirement: 'fire' },
      { name: 'Bottle', icons: ['flip'], vp: 2, requirement: null },
      { name: 'Message', icons: [], vp: 2, requirement: 'bottle' },
      { name: 'Ship', icons: ['ship'], vp: 0, requirement: null },
      { name: 'Ship', icons: ['ship'], vp: 0, requirement: null },
      { name: 'Wild Boar', icons: ['health'], healthBonus: -2, vp: 0, requirement: null },
      { name: 'Quicksand', icons: ['health'], healthBonus: -1, vp: 0, requirement: null },
      { name: 'Storm', icons: ['health'], healthBonus: -2, vp: 0, requirement: null },
      { name: 'Fever', icons: ['health'], healthBonus: -3, vp: 0, requirement: null }
    ];

    // Game state
    let gameState = {
      health: INITIAL_HEALTH,
      deck: [],
      board: Array(BOARD_SIZE * BOARD_SIZE).fill(null),
      playerPosition: null,
      shipPosition: null,
      shipDirection: null,
      shipInPort: true,
      score: 0,
      cardsPlayed: 0,
      gameOver: false,
      rescued: false
    };

    // DOM elements
    const gameBoard = document.getElementById('gameBoard');
    const deck = document.getElementById('deck');
    const healthValue = document.getElementById('healthValue');
    const healthFill = document.getElementById('healthFill');
    const scoreElement = document.getElementById('score');
    const deckCount = document.getElementById('deckCount');
    const gameLog = document.getElementById('gameLog');
    const gameOverElement = document.getElementById('gameOver');
    const gameOverTitle = document.getElementById('gameOverTitle');
    const gameOverMessage = document.getElementById('gameOverMessage');
    const finalScore = document.getElementById('finalScore');
    const newGameBtn = document.getElementById('newGameBtn');
    const restartBtn = document.getElementById('restartBtn');

    // Initialize the game
    function initGame() {
      // Reset game state
      gameState = {
        health: INITIAL_HEALTH,
        deck: [...CARD_TYPES],
        board: Array(BOARD_SIZE * BOARD_SIZE).fill(null),
        playerPosition: null,
        shipPosition: null,
        shipDirection: null,
        shipInPort: true,
        score: 0,
        cardsPlayed: 0,
        gameOver: false,
        rescued: false
      };
      
      // Shuffle deck
      shuffleDeck();
      
      // Create board
      createBoard();
      
      // Update UI
      updateUI();
      
      // Draw first card
      drawFirstCard();
      
      // Log
      logMessage("Game started! Draw your first card and explore the island.");
    }

    // Shuffle the deck
    function shuffleDeck() {
      for (let i = gameState.deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
      }
    }

    // Create game board
    function createBoard() {
      gameBoard.innerHTML = '';
      for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
        const cell = document.createElement('div');
        cell.classList.add('card-placeholder');
        cell.dataset.index = i;
        gameBoard.appendChild(cell);
      }
    }

    // Draw first card
    function drawFirstCard() {
      if (gameState.deck.length === 0) return;
      
      const card = gameState.deck.pop();
      const centerIndex = 5; // Center of the 4x4 grid
      placeCard(card, centerIndex);
      movePlayer(centerIndex);
      gameState.cardsPlayed++;
      
      updateDeckCount();
    }

    // Place a card on the board
    function placeCard(card, index) {
      gameState.board[index] = { ...card, flipped: false };
      renderBoard();
    }

    // Move player to a position
    function movePlayer(index) {
      gameState.playerPosition = index;
      renderBoard();
      
      // Apply health effect of the card if it has a health icon
      const card = gameState.board[index];
      if (card && card.icons.includes('health')) {
        updateHealth(card.healthBonus);
        logMessage(`You ${card.healthBonus > 0 ? 'gained' : 'lost'} ${Math.abs(card.healthBonus)} health from ${card.name}.`);
      }
    }

    // Update player health
    function updateHealth(change) {
      gameState.health += change;
      if (gameState.health <= 0) {
        gameState.health = 0;
        endGame(false, "You ran out of health and perished on the island.");
      }
      updateUI();
    }
    
    // Check if a move is valid
    function isValidMove(targetIndex) {
      if (gameState.board[targetIndex] !== null) return true;
      
      // Check if adjacent to player's current position
      const currentRow = Math.floor(gameState.playerPosition / BOARD_SIZE);
      const currentCol = gameState.playerPosition % BOARD_SIZE;
      const targetRow = Math.floor(targetIndex / BOARD_SIZE);
      const targetCol = targetIndex % BOARD_SIZE;
      
      return Math.abs(currentRow - targetRow) <= 1 && 
             Math.abs(currentCol - targetCol) <= 1 &&
             !(currentRow === targetRow && currentCol === targetCol);
    }

    // Try to flip a card
    function tryFlipCard(index) {
      const card = gameState.board[index];
      if (!card || card.flipped) return false;
      
      // Check if requirement is met
      if (card.requirement) {
        const requirementMet = gameState.board.some(c => 
          c && c.name.toLowerCase() === card.requirement.toLowerCase() && !c.flipped);
        
        if (!requirementMet) {
          logMessage(`You need a ${card.requirement} card to flip this ${card.name} card.`);
          return false;
        }
      }
      
      // Flip the card
      card.flipped = true;
      logMessage(`You flipped the ${card.name} card.`);
      
      // Special actions for flipped cards
      if (card.name === 'SOS' || card.name === 'Beacon' || card.name === 'Message') {
        if (!gameState.shipInPort && gameState.shipPosition !== null) {
          logMessage(`The ship spotted your ${card.name}!`);
          rescuePlayer();
        }
      }
      
      renderBoard();
      return true;
    }

    // Move the ship
    function moveShip() {
      if (gameState.shipInPort || gameState.shipPosition === null) return;
      
      const directions = [
        [-1, 0],  // North
        [0, 1],   // East
        [1, 0],   // South
        [0, -1]   // West
      ];
      
      const [rowDelta, colDelta] = directions[gameState.shipDirection];
      const currentRow = Math.floor(gameState.shipPosition / BOARD_SIZE);
      const currentCol = gameState.shipPosition % BOARD_SIZE;
      
      const newRow = currentRow + rowDelta;
      const newCol = currentCol + colDelta;
      
      // Check if ship is at edge
      if (newRow < 0 || newRow >= BOARD_SIZE || newCol < 0 || newCol >= BOARD_SIZE) {
        // Ship returns to port
        gameState.shipInPort = true;
        gameState.shipPosition = null;
        logMessage("The ship has returned to port.");
      } else {
        // Move ship
        gameState.shipPosition = newRow * BOARD_SIZE + newCol;
        logMessage("The ship moved along the coast.");
        
        // Check if player can be rescued by the ship
        checkShipRescue();
      }
      
      renderBoard();
    }

    // Check if ship can rescue player
    function checkShipRescue() {
      if (gameState.shipPosition === gameState.playerPosition) {
        logMessage("The ship spotted you on the shore!");
        rescuePlayer();
      }
      
      // Check if ship can see SOS, beacon or message
      gameState.board.forEach((card, index) => {
        if (!card || !card.flipped) return;
        
        if ((card.name === 'SOS' || card.name === 'Beacon' || card.name === 'Message')) {
          // Check if ship is adjacent to this card
          const cardRow = Math.floor(index / BOARD_SIZE);
          const cardCol = index % BOARD_SIZE;
          const shipRow = Math.floor(gameState.shipPosition / BOARD_SIZE);
          const shipCol = gameState.shipPosition % BOARD_SIZE;
          
          if (Math.abs(cardRow - shipRow) <= 1 && Math.abs(cardCol - shipCol) <= 1) {
            logMessage(`The ship spotted your ${card.name}!`);
            rescuePlayer();
          }
        }
      });
    }

    // Rescue player
    function rescuePlayer() {
      gameState.rescued = true;
      calculateScore();
      endGame(true, "You've been rescued from the island!");
    }

    // Calculate final score
    function calculateScore() {
      let score = 0;
      
      // Add VP from cards
      gameState.board.forEach(card => {
        if (card) score += card.vp;
      });
      
      // Add health bonus
      score += gameState.health;
      
      // Add bonus for cards played
      score += Math.floor(gameState.cardsPlayed / 4);
      
      gameState.score = score;
      updateUI();
    }

    // End the game
    function endGame(success, message) {
      gameState.gameOver = true;
      gameOverTitle.textContent = success ? "Success!" : "Game Over";
      gameOverMessage.textContent = message;
      finalScore.textContent = gameState.score;
      gameOverElement.style.display = "flex";
    }

    // Render the game board
    function renderBoard() {
      const cells = gameBoard.querySelectorAll('.card-placeholder');
      
      cells.forEach((cell, index) => {
        cell.innerHTML = '';
        const card = gameState.board[index];
        
        if (card) {
          cell.classList.remove('card-placeholder');
          cell.classList.add('card');
          if (card.flipped) cell.classList.add('flipped');
          
          // Icons
          const iconsDiv = document.createElement('div');
          iconsDiv.classList.add('icons');
          
          card.icons.forEach(icon => {
            const iconDiv = document.createElement('div');
            iconDiv.classList.add('icon', `icon-${icon}`);
            
            if (icon === 'health') {
              iconDiv.textContent = card.healthBonus > 0 ? '+' + card.healthBonus : card.healthBonus;
            } else if (icon === 'ship') {
              iconDiv.textContent = '⚓';
            } else if (icon === 'flip') {
              iconDiv.textContent = '↻';
            }
            
            iconsDiv.appendChild(iconDiv);
          });
          
          // Victory points
          const vpDiv = document.createElement('div');
          vpDiv.classList.add('icon', 'icon-vp');
          vpDiv.textContent = card.vp;
          iconsDiv.appendChild(vpDiv);
          
          cell.appendChild(iconsDiv);
          
          // Card name
          const nameDiv = document.createElement('div');
          nameDiv.textContent = card.name;
          nameDiv.style.textAlign = 'center';
          cell.appendChild(nameDiv);
          
          // Flip requirement
          if (card.requirement && !card.flipped) {
            const reqDiv = document.createElement('div');
            reqDiv.classList.add('flip-requirement');
            reqDiv.textContent = `Need: ${card.requirement}`;
            cell.appendChild(reqDiv);
          }
        } else {
          cell.classList.add('card-placeholder');
          cell.classList.remove('card', 'flipped');
        }
      });
      
      // Add player token
      if (gameState.playerPosition !== null) {
        const playerCell = cells[gameState.playerPosition];
        const playerToken = document.createElement('div');
        playerToken.classList.add('footprints');
        playerToken.textContent = '👣';
        playerCell.appendChild(playerToken);
      }
      
      // Add ship token
      if (!gameState.shipInPort && gameState.shipPosition !== null) {
        const shipCell = cells[gameState.shipPosition];
        const shipToken = document.createElement('div');
        shipToken.classList.add('ship');
        shipToken.textContent = '🚢';
        shipCell.appendChild(shipToken);
      }
    }

    // Update UI elements
    function updateUI() {
      healthValue.textContent = gameState.health;
      healthFill.style.width = `${(gameState.health / INITIAL_HEALTH) * 100}%`;
      scoreElement.textContent = gameState.score;
    }

    // Update deck count
    function updateDeckCount() {
      deckCount.textContent = gameState.deck.length;
    }

    // Add message to game log
    function logMessage(message) {
      const logEntry = document.createElement('p');
      logEntry.textContent = message;
      gameLog.appendChild(logEntry);
      gameLog.scrollTop = gameLog.scrollHeight;
    }

    // Player turn
    function playerTurn(targetIndex) {
      if (gameState.gameOver) return;
      
      // Check if it's a valid move
      if (!isValidMove(targetIndex)) {
        logMessage("You can only move to adjacent spaces.");
        return;
      }
      
      // Draw a card if the space is empty
      if (gameState.board[targetIndex] === null) {
        if (gameState.deck.length === 0) {
          logMessage("No more cards in the deck!");
          return;
        }
        
        const card = gameState.deck.pop();
        placeCard(card, targetIndex);
        gameState.cardsPlayed++;
        updateDeckCount();
        
        // Check if it's a ship card
        if (card.icons.includes('ship') && gameState.shipInPort) {
          launchShip(targetIndex);
        }
      }
      
      // Move player
      movePlayer(targetIndex);
      
      // Reduce health
      updateHealth(-1);
      logMessage("You used 1 health point for this turn.");
      
      // Move ship
      moveShip();
    }

    // Launch a ship
    function launchShip(cardIndex) {
      gameState.shipInPort = false;
      
      // Determine ship starting position and direction
      const row = Math.floor(cardIndex / BOARD_SIZE);
      const col = cardIndex % BOARD_SIZE;
      
      let startPos, direction;
      
      // NW corner
      if (row < BOARD_SIZE / 2 && col < BOARD_SIZE / 2) {
        startPos = 0; // NW corner
        direction = 1; // East
      } 
      // NE corner
      else if (row < BOARD_SIZE / 2 && col >= BOARD_SIZE / 2) {
        startPos = BOARD_SIZE - 1; // NE corner
        direction = 2; // South
      }
      // SW corner
      else if (row >= BOARD_SIZE / 2 && col < BOARD_SIZE / 2) {
        startPos = BOARD_SIZE * (BOARD_SIZE - 1); // SW corner
        direction = 0; // North
      }
      // SE corner
      else {
        startPos = BOARD_SIZE * BOARD_SIZE - 1; // SE corner
        direction = 3; // West
      }
      
      gameState.shipPosition = startPos;
      gameState.shipDirection = direction;
      
      logMessage("A ship has set sail and can be seen off the coast!");
      
      // Check if ship can rescue immediately
      checkShipRescue();
    }

    // Event listeners
    gameBoard.addEventListener('click', (e) => {
      const cell = e.target.closest('[data-index]');
      if (!cell) return;
      
      const index = parseInt(cell.dataset.index);
      
      // If the clicked card has the player on it and isn't flipped, try to flip it
      if (gameState.playerPosition === index && 
          gameState.board[index] && 
          !gameState.board[index].flipped) {
        tryFlipCard(index);
      } else {
        playerTurn(index);
      }
    });

    deck.addEventListener('click', () => {
      if (gameState.deck.length === 0 || gameState.gameOver) return;
      
      // Find valid adjacent empty spaces
      const currentRow = Math.floor(gameState.playerPosition / BOARD_SIZE);
      const currentCol = gameState.playerPosition % BOARD_SIZE;
      const validMoves = [];
      
      for (let r = -1; r <= 1; r++) {
        for (let c = -1; c <= 1; c++) {
          if (r === 0 && c === 0) continue;
          
          const newRow = currentRow + r;
          const newCol = currentCol + c;
          
          if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE) {
            const index = newRow * BOARD_SIZE + newCol;
            if (gameState.board[index] === null) {
              validMoves.push(index);
            }
          }
        }
      }
      
      if (validMoves.length === 0) {
        logMessage("No valid moves available!");
        return;
      }
      
      // Select a random valid move
      const randomIndex = Math.floor(Math.random() * validMoves.length);
      playerTurn(validMoves[randomIndex]);
    });

    newGameBtn.addEventListener('click', initGame);
    restartBtn.addEventListener('click', () => {
      gameOverElement.style.display = "none";
      initGame();
    });

    // Initialize the game when page loads
    initGame();
  </script>
</body>
</html>